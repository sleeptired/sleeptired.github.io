---
title: 2026-02-27 TIL (5일차)
date: 2026-02-27
categories: ["TIL(Today I Learned)", "2026-02-27"]
tags: [TIL, "2026", 내일배움캠프, Unreal, C++]
---
## Unreal 강의
1. 상태 머신 설계하는 방법
   ● 오브젝트가 가질 수 있는 모든 상태 정리 (대기,걷기,달리기 등등)
   ● 상태1 -> 상태2 처럼 현재 상태에서 다른 상태로 변경 될 때마다 모든 조건 정리 


## C++ 공부 (3일차)
1. **함수 포인터**
   >● 변수 포인터는 메모리 절약과 효율인데 함수 포인터는 **결정의 유연성(코드의 설계)** 을 위한 것입니다.
   {: .prompt-tip }

   구현되는 원리는 포인터랑 같다!  
   포인터라는 상자 안에 '주소'를 담는다는 점은 변하지 않아요. 다만, 그 주소가 데이터를 가리키느냐, 함수를 가리키느냐의 차이일 뿐
   차이점: 가리키는 공간이 다름.    
   ( 변수 포인터 - 스택,힙,데이터 , 함수 포인터 - 코드[ Code / Text ] 영역)

   ```cpp
   int foo()
   {
    return 5;
   }

   int goo()
   {
    return 6;
   }

   int main()
   {
    int (*fcnPtr)() = foo; // fcnPtr points to function foo
    fcnPtr = goo; // fcnPtr now points to function goo
       return 0;
   }
   ```
   C++는 기본 자료형과 달리 필요할 경우 함수를 함수 포인터로 암묵적으로 변환하므로 주소 연산자 &를 사용할 필요가 없다.  
   이유: 배열이랑 비슷한 개념이다.  
   ●함수는 코드 영역에 저장된 명령어들의 **집합** 이기 때문에 함수이름이 시작 주소(진입점 주소)이다.  
   ★**함수는 시작점부터 실행해야 하는 존재다. 그래서 이름 자체가 곧 시작 주소로 통하도록 설계되었다!**  

   **실행예시**  
   1. 함수 누구를 부를지를 실행 중에 결정하기 위해서 (런타임 결정)

   ```cpp
   void Attack() 
   {
    std::cout << "기본 공격" << std::endl;
   }

   void Defense() 
   {
    std::cout << "기본 방어" << std::endl;
   }

   int main()
   {
    void (*ptr)() = nullptr;
    int input;
    std::cin >> input;

    if (input == 1) 
    {
        ptr = Attack;
    }
    else if (input == 2) 
    {
        ptr = Defense;
    }
    
    if (ptr != nullptr) //만약 이 조건문이 없으면 input값이 1,2가 아니면 nullptr에 있는 함수를 실행을 시켜서 오류가 생김
    {
        ptr();
    }
   }
   ```

   2. 함수를 부품처럼 갈아 끼우기 (전략패턴)
      
   ```cpp
   bool Better(int a, int b) 
   {   
       return a > b;
   }

   bool Worese(int a, int b) 
   {
       return a < b; 
   }

   void Sort(int* arr, int size, bool (*compare)(int, int)) 
   //배열을 포인터로 받고 , 0부터 size-1만큼 정렬한다, 무슨 함수를 포인터로 받고 넘길꺼냐? 이러면 bool 함수+매개변수 2개인 함수는 다 가능
   {
       for (int i = 0; i < size - 1; i++) 
       {
           for (int j = i + 1; j < size; j++) 
           {
               if (compare(arr[i], arr[j]))//저장되어있는 함수의 주소로가서 실행함 
               { 
                   std::swap(arr[i], arr[j]);
               }
           }
       }
   }
   ```

   3. 콜백, Callback

   ```cpp
   void OnCompleteNotify() 
   {
       std::cout << "팝업" << std::endl; 
   }
   void OnCompleteLogin() 
   {
       std::cout << "로그인" << std::endl;
   }

   void DownloadFile(void (*callback)()) 
   { 
       std::cout << "다운로드 중..." << std::endl;
       callback(); //"아까 할당 받은 주소로 다시 가 
       std::cout << "다운로드 중2..." << std::endl;
   }
   int main()
   {
       DownloadFile(OnCompleteNotify);
       //OnCompleteNotify라는 이름(주소)을 복사해서 callback이라는 매개변수에 저장
       //DownloadFile을 실행 시키는데 callback 실행 -> 안에는 OnCompleteNotify저장되어있음
       // OnCompleteNotify가 끝나면 **다시 DownloadFile** 로 돌아온다. (당연히 자신위치 뒤 부터 실행시킨다.)
   }
   ```
 
2. Dangling Pointer
3. 얕은복사 깊은복사
4. 스택 프레임

## 게임 수학
1. 삼각함수 (26일차에 사용했던 앞뒤,양옆으로 갈 때 왜 그렇게 가는지 수학적 이유)
   
