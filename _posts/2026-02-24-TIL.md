---
title: 2026-02-24 TIL (2일차)
date: 2026-02-24
categories: ["TIL(Today I Learned)", "2026-02-24"]
tags: [TIL, "2026", 내일배움캠프, DirectX 11, Unreal, Unity, C#]
---

## **DirectX 11 입문**
 >**3D 게임 세계의 객체들을 컴퓨터의 화면(2D)으로 그리는 것, 또는 그리는 과정을 렌더링(Rendering)이라고 한다.**
 {: .prompt-tip }


 **그래픽스 기하학적 구성 요소 정리 용어 정리**  
 ● 점들의 집합 -> 선분  
 ● 선분들의 집합 -> 다각형  
 ● 점들을 일련의 선분으로 연결 -> 면  
 ● 다각형들의 집합, 다각형 면들의 집합 -> 메시  
 ● 메시를 구성하는 점들 -> 정점(Vertex)  


 <span style="color: red">**렌더링 과정**  
 >변환(Transformation), 색칠(Coloring, Lighting)으로 구분 가능합니다.  
 {: .prompt-tip }


 다각형의 점들의 색상의 결정은 **조명처리** 또는 **텍스처 매핑**등의 개념이 포함됩니다.

## **인턴십 공고 지원 준비**
 오늘도 취업을 위해 채용공고 사이트를 검색하고 있던 중 인턴십 공고를 하나 보게 되었습니다.  
 필요역량은 유니티를 필수 역량으로 보는 것 같습니다.  
 그래서 당분간 요일마다 정해놓았던 공부를 멈추고 c#과 유니티 공부를 부트캠프에 영향이 안 가게 학습할 예정입니다.  

## **현재 나의 유니티 역량**
 대학교 3~4학년 때 그래픽스 과목 프로젝트와 졸업 과제인 팀 프로젝트에서 유니티를 다루어 보았고 2026년도 1월 말부터 2월 초까지 3D Moba Network 게임을 구현했습니다.    
 이렇게 경험이 있어도 3~4학년 때는 유튜브 강의를 보면서 구현했었고 최근 들어서 만든 게임은 단기간에 기술만 구현해 보려고 만든 프로젝트여서 유니티의 지식  깊이가 그리 깊다고는 생각 안 해서 이번에 유니티 엔진과 c#을 깊이 있게 공부해 볼 예정입니다.  

## **유니티 엔진이 동작하는 원리**
 2026-02-23일에 다루었던 컴포넌트 패턴이 유니티가 씬과 오브젝트를 구성하고 동작시키는 핵심적인 원리입니다.  
하지만 컴포넌트는 서로 관심이 없고 유니티 엔진 또한 어떤 게임 오브젝트에 어떤 컴포넌트가 추가되었는지 그 모든 명단을 모조리 파악하지 않습니다.  
<span style="color: #3388ff">**따라서 유니티는 컴포넌트의 어떤 기능을 실행시키고 싶을 때 메시지를 날리는 브로드 캐스팅 방식을 사용합니다.**  

 메세지 방식의 특징  
 1. 메시지를 보내는 쪽은 누가 받게 될지 신경 안쓴다.
 2. 메세지 받은 쪽은 누가 보냈는지 신경 안쓴다.
 3. 메시지를 받았을 때 메세지에 명시된 기능을 가지고 있다면 실행하고 없다면 무시한다.

## **Unreal 강의 새로 알게되거나 궁금한 부분**

**1. 빙의(possess) 기능**  
캐릭터 오브젝트를 클릭하고 디테일 패널에 possess를 검색하면 Auto Possess Player 항목에 현재 프로젝트 게임에 설정된 플레이어 번호를 할당하면 조종할 수 있는 플레이어를 변경할 수 있습니다.

**2. 로컬좌표계, 월드좌표계 차이**  
로컬좌표계는 맵의 정중앙(절대적인 기준)을 통해 위치를 변경하는 것입니다.  
월드좌표계는 액터 자신을 기준으로 위치를 변경하는 것입니다.

<span style="color: red">쉽게 **예시**롤 설명해드리겠습니다.
>캐릭터가 무기를 들오있고 맵에서 **오른쪽(동쪽)**을 바라보고 서 있는 상황입니다.  
>● 무기의 로컬 x좌표를 100증가 시켰을 때  
>캐릭터가 바라보고 있는 **오른쪽(동쪽)** 방향으로 100만큼 떨어집니다.  
>● 무기의 월드 x좌표를 100증가 시켰을 때  
>무기가 캐릭터의 앞쪽이 아니라, 캐릭터의 왼쪽 **옆구리(북쪽)** 방향으로 100만큼 떨어집니다.  
{: .prompt-tip }


**3. 메테리얼 용어정리**  
● **메탈릭**: 금속 특유의 반사광 색상과 주변 환경을 반사하는 정도를 조절합니다.  
(0이면 비금속 1이면 금속 재질)  
● **스페큘러**: 주로 플라스틱이나 유리 같은 비금속의 '번들거림'을 미세하게 조정할 때 씁니다.  
(0이면 탁한 재질 1이면 빛 반사가 강한 매끄러운 재질)  
● **러프니스**: 면의 거친 정도를 결정합니다. 재질의 느낌을 결정하는 가장 중요한 요소입니다.  
(0이면 거울,유리처럼 선명하게 반사 1이면 반사광이 거의 보이지 않음)  
● **애니소트로피**: 반사광의 방향성을 조절합니다.  
(0이면 반사광이 원형으로 일정하게 맺힘 1이면 반사광이 결을 따라 길쭉하게 늘어짐)  
● **이미시브 컬러**: 물체 스스로 빛을 내는 효과입니다.  
(0이면 빛을 안내서 검게 보임 1이면 물체가 스스로 빛나서 할당된 메시를 나타나게 함 1보다 큰 값은 눈부시게 효과를 낼 수 있음)  

## **심화 버전 비트 연산자**
비트 연산자의 사용방법  

`Bitwise.cpp`
{: .filepath}

```cpp
int A = 1 << 4 >> 1, // 0001 0000 -> 0000 1000 (8)
int B = 4 << 4, // 0100 -> 0100 0000 (64)
int C = 5 << 4 // 0000 0101 -> 0101 0000 (80)
```

**비트연산자의 >> or << 이거는 2진수로 표현해서 나온 1들을 연산자 뒤에 나오는 수 만큼 이동시키는 기능입니다.**

● &(곱,AND): 둘 다 1일 때만 1이다.  
● |(합,OR): 하나라도 1이면 1이다.  

```cpp
//Bitwise 코드랑 이어집니다.
B = A & B; // A: 0000 1000 과 B: 0100 0000 과 각 자릿수를 비교할 때 둘다 1인 경우는 없으므로 0이 나옵니다.
C = A | B; // B: 0100 0000 과 C: 0101 0000 과 각 자릿수를 비교할 때 하나라도 1인 경우는 0101 0000이므로 80이 나옵니다.
```

게임에서는 주로 저가 구현했었던 오브젝트 **상태이상**에서 사용되거나 엔진의 **충돌 레이어 필터링**에 사용됩니다.
