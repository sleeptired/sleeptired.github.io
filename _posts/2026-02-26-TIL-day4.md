---
title: 2026-02-26 TIL (4일차)
date: 2026-02-26
categories: ["TIL(Today I Learned)", "2026-02-26"]
tags: [TIL, "2026", 내일배움캠프, Unreal, 컴퓨터 구조]
---
## **Unreal 강의**
1. Persistent Level: 가장 먼저 로드되고, 맵을 떠날 때까지 메모리에서 내려가지 않는 레벨  
   (하늘, 태양빛,땅바닥)  
   Sub Level: 퍼시스턴트 레벨 공간 안에 배치되어, 필요할 때만 메모리에 로드되거나 삭제될 수 있는 맵의 조각  
   (서브 레벨 A - 집과 NPC, 서브 레벨 B- 나무와 몬스터)  
   
2. 언리얼 엔진에서 회전은 오일러 각도 방식을 사용하며, X, Y, Z 각 축을 중심으로 회전하는 것을 Roll, Pitch, Yaw라고 부릅니다.  
   **3D 공간에서 '어느 각도로 돌아가 있는가'를 나타냅니다.**
   
   | 용어 | 회전 축 | 설명 |
   | :--- | :---: | :--- |
   | **Yaw** | Z축 | 수직축을 중심으로 좌우로 회전 |
   | **Pitch** | Y축 | 가로축을 중심으로 위아래로 회전 |
   | **Roll** | X축 | 앞뒤축을 중심으로 좌우로 기울어짐 |

   **이미지 예시**  
   ![Euler Angles](/Euler%20Angles.png){: .shadow width="400" }  

   **구현예시**: 잘모르겠어서 직접 하나씩 보고도 모르겠으면 튜터님한테 물어보기  
   
   
3. Input Action에셋에서 설정한 그 Value Type이 블루프린트에서 해당 입력을 불렀을 때 나오는 'Action Value' 핀 - 데이터 타입의 종류의 의미

   | Value Type | 데이터 형태 | 비유 | 예시 |
   | :--- | :---: | :--- | :--- |
   | **Digital** | Boolean | 스위치 ON/OFF | 스페이스바 (점프) |
   | **Axis1D** | Float | 볼륨 조절 다이얼 | 마우스 휠 (줌) |
   | **Axis2D** | Vector2D | 조이스틱 (상하좌우) | WASD (캐릭터 이동) |
   | **Axis3D** | Vector | 공간 좌표 (X, Y, Z) | VR 컨트롤러 위치 |

   
4. Input Mapping Context에 있는 modifiers의 정의 및 종류
   입력값을 내가 원하는 형태로 **미리** 가공해서 건네주는 것  
   (사용하는 이유: 키보드나 마우스는 눌렀어라고 정해진 값만 주기 때문에 상황에 따라 값을 변경해줘야해서 미리 모디파이어[필터]를 사용한다.)

   | 모디파이어 이름 | 핵심 역할 |
   | :--- | :---: |
   | **Negate** | 플러스(+)를 마이너스(-)로 |
   | **Swizzle** | X, Y, Z 자리를 바꿈 |
   | **Dead Zone** | 작은 떨림 무시 |
   | **Scalar** | 힘 조절 (곱셈) |
   | **To World Space** | 입력 좌표를 월드 기준으로 변환 |
   
   
5. Get **Self** vs **Control** Rotation 움직임 차이의 이유
   
   | 이름 | 기준점 |
   | :--- | :---: |
   | **Self** | 오브젝트의 자기자신의 기준으로 보는 방향 |
   | **Control** | 플레이어가 화면을 통해 보고 있는 **정면**을 기준으로 보는 방향 |

   그러므로 Self로 방향벡터를 받으면 오른쪽으로 갈려고하면 계속 정면이 달라져서 그 달라지는 기준으로 방향이 달라져서 한 바퀴를 도는 형상이 나온다.  
   Control는 오브젝트가 움직여도 화면 자체를 기준으로 해서 오브젝트 보는 방향이 달라져도 화면 방향 벡터가 달라지는게 아니라서 원하는 방향으로 간다.  
   

## **컴퓨터 구조 + 운영체제 (1일차)**
1. **왜 컴퓨터 언어에서 시작은 0부터일까?**
   배열이 0부터 시작하는 이유는 인덱스 번호가 시작점에서 얼마나 멀리 떨어져 있는가를 나타내기 때문입니다.

  
   **int arr[3] (시작 주소가 1000번지라고 가정)**

   | 인덱스 | 계산식: 주소+ (인텍스 * 자료형 크기) | 실제 주소 | 의미 |
   | :--- | :---: | :--- | :--- |
   | arr[0] | 1000 + ( 0 * 4 [ int ] ) | 1000 | 시작점에서 0바이트 이동 |
   | arr[1] | 1000 + ( 1 * 4 [ int ] ) | 1004 | 시작점에서 4바이트 이동 |
   | arr[2] | 1000 + ( 2 * 4 [ int ] ) | 1008 | 시작점에서 8바이트 이동 |
   
